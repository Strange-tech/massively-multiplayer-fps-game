
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #instructions {
            width: 100%;
            height: 100%;
            display: -webkit-box;
            display: -moz-box;
            /*display: box;*/
            -webkit-box-orient: horizontal;
            -moz-box-orient: horizontal;
            box-orient: horizontal;
            -webkit-box-pack: center;
            -moz-box-pack: center;
            box-pack: center;
            -webkit-box-align: center;
            -moz-box-align: center;
            box-align: center;
            color: #ffffff;
            text-align: center;
            cursor: pointer;
        }
    </style>
    <title></title>
</head>

<body style='overflow-y:hidden;overflow-x:hidden'>

<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">点击屏幕开始</span>
        <br />
        <br />
        (W, A, S, D = 移动, SPACE = 跳跃, MOUSE = 移动视角)
    </div>
</div>

<script type="module">

    import * as THREE from '../build/three.module.js';
    import { PointerLockControls } from './jsm/controls/PointerLockControls.js';
    import {GLTFLoader} from './jsm/loaders/GLTFLoader.js';

    let camera, scene, renderer, controls;
    // let human;
    const objects = [];
    let rayCaster;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;
    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const vertex = new THREE.Vector3();
    const color = new THREE.Color();
    /*程序开始*/
    init();
    animate();

    function initCamera() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 10;//固定相机高度
        // camera.position.set(100, 100, 100);
        // camera.rotation.set(-1.5014844872712905,  -0.9816239548295801,  -1.487488);
        // camera.up.set(0, 1, 0);
        // camera.lookAt(0, 0, 0);
    }
    function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.Fog(0xffffff, 0, 750);
    }
    function initLight() {
        const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);
    }
    function initControls() {

        controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        instructions.addEventListener('click', function () {
            controls.lock();
        });
        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });
        controls.addEventListener('unlock', function () {
            blocker.style.display = 'block';
            instructions.style.display = '';
        });
        scene.add(controls.getObject());
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    function activateAllActions() {

        setWeight( idleAction, settings[ 'modify idle weight' ] );
        setWeight( walkAction, settings[ 'modify walk weight' ] );
        setWeight( runAction, settings[ 'modify run weight' ] );

        actions.forEach( function ( action ) {

            action.play();

        } );

    }
    function updateWeightSliders() {

        settings[ 'modify idle weight' ] = idleWeight;
        settings[ 'modify walk weight' ] = walkWeight;
        settings[ 'modify run weight' ] = runWeight;

    }
    function updateCrossFadeControls() {

        crossFadeControls.forEach( function ( control ) {

            control.setDisabled();

        } );

        if ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {

            crossFadeControls[ 1 ].setEnabled();

        }

        if ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {

            crossFadeControls[ 0 ].setEnabled();
            crossFadeControls[ 2 ].setEnabled();

        }

        if ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {

            crossFadeControls[ 3 ].setEnabled();

        }

    }
    function animate() {

        requestAnimationFrame(animate);
        const time = performance.now();
        if (controls.isLocked === true) {
            playControl(time);
        }
        prevTime = time;
        // renderer.render(scene, camera);
        // Render loop

        idleWeight = idleAction.getEffectiveWeight();
        walkWeight = walkAction.getEffectiveWeight();
        runWeight = runAction.getEffectiveWeight();

        // Update the panel values if weights are modified from "outside" (by crossfadings)

        updateWeightSliders();

        // Enable/disable crossfade controls according to current weight values

        updateCrossFadeControls();

        // Get the time elapsed since the last frame, used for mixer update (if not in single step mode)

        let mixerUpdateDelta = clock.getDelta();

        // If in single step mode, make one step and then do nothing (until the user clicks again)

        if ( singleStepMode ) {

            mixerUpdateDelta = sizeOfNextStep;
            sizeOfNextStep = 0;

        }

        // Update the animation mixer, the stats panel, and render this frame

        mixer.update( mixerUpdateDelta );

        stats.update();

        renderer.render( scene, camera );

    }
    function putHuman(src, pos){
        const loader = new GLTFLoader();
        loader.load( 'models/gltf/Soldier.glb', function ( gltf ) {

            model = gltf.scene;
            model.position.set(0,30,30);
            scene.add( model );

            model.traverse( function ( object ) {

                if ( object.isMesh ) object.castShadow = true;

            } );

            skeleton = new THREE.SkeletonHelper( model );
            skeleton.visible = false;
            scene.add( skeleton );

            // createPanel();

            const animations = gltf.animations;

            mixer = new THREE.AnimationMixer( model );

            idleAction = mixer.clipAction( animations[ 0 ] );
            walkAction = mixer.clipAction( animations[ 3 ] );
            runAction = mixer.clipAction( animations[ 1 ] );

            actions = [ idleAction, walkAction, runAction ];

            activateAllActions();

            animate();

        } );
        // new GLTFLoader().load(src, function(glb){
        //     scene.add(glb.scene);
        //     glb.scene.position.set(pos.x,pos.y,pos.z);//初始位置
        //     // console.log(glb);
        //     glb.scene.scale.set(10, 10, 10);
        //     console.log(glb.scene);
        //     playAnimation(glb);
        //     function playAnimation(G) {//播放动画
        //         const meshMixer2 = new THREE.AnimationMixer(G.scene);
        //         meshMixer2.clipAction(G.animations[0]).play();
        //         setInterval(function () {
        //             meshMixer2.update(0.01);//更新动作
        //             // glb.scene.position.x=pos.x;
        //             // glb.scene.position.y=pos.y;
        //             // glb.scene.position.z=pos.z;
        //         }, 20);
        //     }
        // });
    }

    function addModels() {

        const axisHelper = new THREE.AxesHelper(250);
        scene.add(axisHelper);
        /*floor*/
        let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        floorGeometry.rotateX(- Math.PI / 2);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0xC0C0C0 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        scene.add(floor);
        /*box*/
        const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
        // const colorsBox = [];
        const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(20, 20, 20);
        scene.add(box);
        objects.push(box);
        /*human*/
        putHuman();


    }
    function render() {
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true});
        renderer.autoClear = false;
        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
    }
    function playControl(time) {
        // console.log(controls.getObject().position);

        // rayCaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);
        // rayCaster.ray.origin.copy(controls.getObject().position);
        // rayCaster.ray.origin.y -= 10;
        // const intersections = rayCaster.intersectObjects(objects);
        // const onObject = intersections.length > 0;
        // const delta = (time - prevTime) / 1000;
        // velocity.x -= velocity.x * 10.0 * delta;
        // velocity.z -= velocity.z * 10.0 * delta;
        // velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
        // direction.z = Number(moveForward) - Number(moveBackward);
        // direction.x = Number(moveRight) - Number(moveLeft);
        // direction.normalize(); // this ensures consistent movements in all directions
        // if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
        // if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
        // if (onObject === true) {
        //     velocity.y = Math.max(0, velocity.y);
        //     canJump = true;
        // }
        // controls.moveRight(- velocity.x * delta);
        // controls.moveForward(- velocity.z * delta);
        // controls.getObject().position.y += (velocity.y * delta); // new behavior
        // if (controls.getObject().position.y < 10) {
        //     velocity.y = 0;
        //     controls.getObject().position.y = 10;
        //     canJump = true;
        // }


    }

    function init() {

        initCamera();

        initScene();

        initLight();

        initControls();

        addModels();

        render();

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }



</script>
</body>

</html>