<!--测试代码2 第一人称+鼠标+键盘+射线碰撞，模型为自行添加，未导入射击，碰撞，第一人称模型-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #instructions {
            width: 100%;
            height: 100%;
            display: -webkit-box;
            display: -moz-box;
            /*display: box;*/
            -webkit-box-orient: horizontal;
            -moz-box-orient: horizontal;
            box-orient: horizontal;
            -webkit-box-pack: center;
            -moz-box-pack: center;
            box-pack: center;
            -webkit-box-align: center;
            -moz-box-align: center;
            box-align: center;
            color: #ffffff;
            text-align: center;
            cursor: pointer;
        }
    </style>
    <title></title>
    <!--    <img>-->
</head>

<body style='overflow-y:hidden;overflow-x:hidden'>

<div id="blocker">
    <div id="instructions">
        <span style="font-size:40px">点击屏幕开始</span>
        <br/>
        <br/>
        (W, A, S, D = 移动, SPACE = 跳跃, MOUSE = 移动视角)
    </div>
</div>

<script type="module">

    import * as THREE from '../build/three.module.js';
    import {PointerLockControls} from './jsm/controls/PointerLockControls.js';
    import {GLTFLoader} from './jsm/loaders/GLTFLoader.js';

    let camera, scene, renderer, controls;
    let rayCaster;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;
    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const vertex = new THREE.Vector3();
    const color = new THREE.Color();
    let gun, aim;
    const objects = [];
    const collimator = new THREE.Vector2(0, 0);//准星


    /*程序开始*/
    init();
    animate();

    function initCamera() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 100;//固定相机高度
        // camera.position.set(100, 100, 100);
        // camera.rotation.set(-1.5014844872712905,  -0.9816239548295801,  -1.487488);
        // camera.up.set(0, 1, 0);
        // camera.target = new THREE.Vector3(0, 0, 0);
    }

    function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.Fog(0xffffff, 0, 750);
    }

    function initLight() {
        const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);
    }

    function initControls() {

        controls = new PointerLockControls(camera, document.body);
        controls.getObject().target = new THREE.Vector3(0, 0, 0);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        instructions.addEventListener('click', function () {
            controls.lock();
        });
        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });
        controls.addEventListener('unlock', function () {
            blocker.style.display = 'block';
            instructions.style.display = '';
        });
        scene.add(controls.getObject());
        document.addEventListener('keydown', function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;
            }
        });
        document.addEventListener('keyup', function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        });
        const rayCaster = new THREE.Raycaster();
        document.addEventListener('click', () => {
            //可以理解为从相机位置到屏幕位置发射一条射线（3d->2d）
            rayCaster.setFromCamera(collimator, camera);
            //计算射线是否与物体相交
            const intersects = rayCaster.intersectObjects(objects);
            console.log(intersects);
        });
    }

    function putHuman(src) {
        new GLTFLoader().load(src, function (glb) {
            console.log(glb)
            scene.add(glb.scene);
            setInterval(function () {
                glb.scene.rotation.set(
                    camera.rotation.x,
                    camera.rotation.y,
                    camera.rotation.z
                );
                glb.scene.position.set(
                    camera.position.x,
                    camera.position.y - 15,
                    camera.position.z
                );
            }, 10)
            // console.log(glb);
            glb.scene.scale.set(10, 10, 10);
            console.log(glb.scene);
            playAnimation(glb);

            function playAnimation(G) {//播放动画
                const meshMixer2 = new THREE.AnimationMixer(G.scene);
                meshMixer2.clipAction(G.animations[0]).play();
                setInterval(function () {
                    meshMixer2.update(0.01);//更新动作
                    // glb.scene.position.x=pos.x;
                    // glb.scene.position.y=pos.y;
                    // glb.scene.position.z=pos.z;
                }, 20);
            }
        });
    }

    // function moveHuman(){
    //
    // }
    function addModels() {

        /*添加世界坐标轴*/
        const axisHelper = new THREE.AxesHelper(250);
        scene.add(axisHelper);

        /*地面*/
        let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        floorGeometry.rotateX(-Math.PI / 2);
        const floorMaterial = new THREE.MeshBasicMaterial({color: 0xC0C0C0});
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        scene.add(floor);

        /*靶子*/
        const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
        // const colorsBox = [];
        const boxMaterial = new THREE.MeshBasicMaterial({color: 0x0000ff});
        aim = new THREE.Mesh(boxGeometry, boxMaterial);
        aim.position.set(0, 100, 50);
        objects.push(aim);

        scene.add(aim);
        /*human*/
        // putHuman("./models/gltf/Soldier.glb");

        /*添加枪*/
        let gunGeometry = new THREE.BoxGeometry(10, 10, 20);
        gun = new THREE.Mesh(
            gunGeometry,
            new THREE.MeshBasicMaterial({color: 0x00ff00})
        );
        gun.position.set(15, -10, -30);
        camera.add(gun);

        /*添加准星（方形的）*/
        let pointsMaterial = new THREE.PointsMaterial({color: 0xff0000});
        let geometry = new THREE.BufferGeometry();
        let pointsArray = new Array(new THREE.Vector3(0, 0, -10));
        geometry.setFromPoints(pointsArray);
        let shootPoint = new THREE.Points(geometry, pointsMaterial);
        shootPoint.scale.set(3, 3, 3);
        camera.add(shootPoint);

    }

    function render() {
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.autoClear = false;
        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
    }

    function playControl(time) {

        const delta = (time - prevTime) / 1000;
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); // this ensures consistent movements in all directions
        if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
        // if (onObject === true) {
        //     velocity.y = Math.max(0, velocity.y);
        //     canJump = true;
        // }
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y += (velocity.y * delta); // new behavior
        if (controls.getObject().position.y < 100) {
            velocity.y = 0;
            controls.getObject().position.y = 100;
            canJump = true;
        }

    }

    function init() {

        initCamera();

        initScene();

        initLight();

        initControls();

        addModels();

        render();

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        if (controls.isLocked === true) {
            playControl(time);
        }
        prevTime = time;
        renderer.render(scene, camera);
    }


</script>
</body>

</html>